# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# Inpired by https://www.runway.team/blog/how-to-set-up-a-ci-cd-pipeline-for-your-ios-app-fastlane-github-actions

default_platform(:ios)

platform :ios do

  desc "Generate new localized screenshots"
  lane :screenshots do
    capture_screenshots(workspace: "CoopCycle.xcworkspace", scheme: "CoopCycleUITests")
  end
  lane :deploy do
    build_app(workspace: "CoopCycle.xcworkspace", scheme: "CoopCycle")
  end

  desc "Generate icons"
  lane :generate_icons do
    appicon(
      # FIXME Should be passed via env var APPICON_IMAGE_FILE
      # https://github.com/fastlane-community/fastlane-plugin-appicon/blob/master/lib/fastlane/plugin/appicon/actions/appicon_action.rb
      # appicon_image_file: 'metadata-naofood/app_icon.png',
      appicon_devices: [:iphone, :ipad, :ios_marketing],
      appicon_path: 'ios/CoopCycle/Images.xcassets',
    )
  end

  desc "Rename app"
  lane :rename_app do

    if not ENV.has_key?("COOPCYCLE_APP_NAME")
      puts "No custom app name, skipping"
      next
    end

    app_name = ENV["COOPCYCLE_APP_NAME"]

    # update_app_identifier(
    #   xcodeproj: "CoopCycle.xcodeproj", # Optional path to xcodeproj, will use the first .xcodeproj if not set
    #   plist_path: "CoopCycle/Info.plist", # Path to info plist file, relative to xcodeproj
    #   app_identifier: "org.coopcycle.Naofood" # The App Identifier
    # )

    project = Xcodeproj::Project.open("../ios/CoopCycle.xcodeproj")

    project.targets.each do |target|
      target.build_configurations.each do |config|
        if config.build_settings['PRODUCT_NAME'] == "CoopCycle"
          config.build_settings['PRODUCT_NAME'] = app_name
        end
      end
    end

    project.objects.each do |object|
      if object.class == Xcodeproj::Project::Object::PBXFileReference and object.path == "CoopCycle.app"
        object.path = app_name + ".app"
      end
    end

    project.save

    update_info_plist(
      xcodeproj: "ios/CoopCycle.xcodeproj",
      plist_path: "CoopCycle/Info.plist",
      display_name: app_name
    )

  end

  desc "Load ASC API Key information to use in subsequent lanes"
  lane :load_asc_api_key do
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY"],
      is_key_content_base64: true,
      in_house: false # detecting this via ASC private key not currently supported
    )
  end

  desc "Check certs and profiles"
  lane :prepare_signing do |options|
    app_id = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    profile_name = "Fastlane" # replace with the name of your existing profile, or define a name for the profile that fastlane will create if it’s not found

    # delete_keychain(name: "signing_app_temp.keychain-db")

    # create_keychain(
    #   # path: ENV["KEYCHAIN_PATH"],
    #   name: "signing_app_temp.keychain-db",
    #   password: ENV["KEYCHAIN_PASSWORD"],
    #   unlock: true
    # )

    # keychain_path = lane_context[SharedValues::KEYCHAIN_PATH]

    cert(
      api_key: api_key,
      keychain_path: "~/Library/Keychains/signing_temp.keychain-db", # the path to the keychain where your certificates are stored
      # keychain_password: ENV["KEYCHAIN_PASSWORD"]
    )

    # main app profile
    sigh(
      api_key: api_key,
      app_identifier: app_id,
      provisioning_name: profile_name,
      force: true # always recreate this exact profile to ensure it's valid and not expired
    )
  end

  desc "Bump build number based on most recent TestFlight build number"
  lane :fetch_and_increment_build_number do
    #fetch read your app identifier defined in your Appfile
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    current_version = get_version_number(
      xcodeproj: "ios/CoopCycle.xcodeproj",
      target: "CoopCycle" # replace with your main target, required if you have more than one non-test target
    )
    latest_build_number = latest_testflight_build_number(
      api_key: api_key,
      version: current_version,
      app_identifier: app_identifier
    )

    increment_build_number(
      xcodeproj: "ios/CoopCycle.xcodeproj",
      build_number: (latest_build_number + 1),
    )

    # increment_version_number(
    #   bump_type: "patch" # Automatically increment patch version number
    # )
  end

  desc "Build the iOS app for release"
  lane :build_release do |options|
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)

    # profile_name = "Fastlane" # the name of the profile to use for the build
    profile_name = lane_context[SharedValues::SIGH_NAME]
    output_name = "example-iOS" # specify the name of the .ipa file to generate
    export_method = "app-store" # specify the export method
    compile_bitcode = true # specify whether to enable bitcode

    # turn off automatic signing during build so correct code signing identity is guaranteed to be used
    update_code_signing_settings(
      path: "ios/CoopCycle.xcodeproj",
      use_automatic_signing: false,
      targets: ["CoopCycle"], # specify which targets to update code signing settings for
      code_sign_identity: "Apple Distribution", # replace with name of code signing identity if different
      bundle_identifier: app_identifier,
      profile_name: profile_name,
      build_configurations: ["Release"] # only toggle code signing settings for Release configurations
    )

    # build the app
    gym(
      workspace: "ios/CoopCycle.xcworkspace",
      scheme: "CoopCycle", # replace with name of your project’s scheme
      output_name: output_name,
      configuration: "Release",
      export_options: {
        method: export_method,
        provisioningProfiles: {
          app_identifier => profile_name
        },
        compileBitcode: compile_bitcode
      }
    )
  end

  desc "Upload to TestFlight / ASC"
  lane :upload_release do
    api_key = lane_context[SharedValues::APP_STORE_CONNECT_API_KEY]

    upload_to_app_store(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      skip_app_version_update: true,
      force: true, # skips verification of HTML preview file (since this will be run from a CI machine)
      run_precheck_before_submit: false # not supported through ASC API yet
    )
  end

  desc "Build and upload to TestFlight"
  lane :build_upload_testflight do
    load_asc_api_key
    prepare_signing
    fetch_and_increment_build_number
    build_release
    upload_release
  end

end
